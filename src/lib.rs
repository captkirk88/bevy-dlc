//! bevy-dlc — DLC gating utilities for Bevy 0.18
//!
//! Preload encrypted assets and unlock them using offline-signed (Ed25519)
//! tokens. See `DlcManager`, `DlcKey`, and `DlcPack` for the runtime API and
//! examples.

use base64::Engine as _;
use base64::engine::general_purpose::URL_SAFE_NO_PAD;
use bevy::prelude::*;
use ring::signature::{ED25519, Ed25519KeyPair, KeyPair, UnparsedPublicKey};

use secure_gate::{dynamic_alias, fixed_alias, ExposeSecret};

#[cfg(feature = "example")]
pub use secure as secure_crate;


mod asset_loader;
mod content_key_registry;
use aes_gcm::{Aes256Gcm, KeyInit, Nonce, aead::Aead};
pub use asset_loader::{DlcLoader, DlcPack, DlcPackLoader, EncryptedAsset, parse_encrypted};

// ring is used directly for Ed25519 operations — no external signer trait.
use serde::{Deserialize, Serialize};
use std::collections::HashSet;

use thiserror::Error;

#[cfg(any(test, feature = "example"))]
pub mod example_util;

pub mod prelude {
    pub use super::AppExt;
    pub use crate::{
        DlcError, DlcHandle, DlcId, DlcKey, DlcLoader, DlcManager, DlcPack, DlcPackLoader,
        DlcPlugin, Product, SignedLicense, VerifiedLicense, dlc_unlocked,
    };
}

pub trait AppExt {
    /// Register a `DlcLoader` for the given asset type `T`. This is required for any asset type that may be loaded from a DLC pack. The plugin registers loaders for common asset types (Image, Scene, Mesh, Font, AudioSource) but you must register loaders for any custom asset types.
    ///
    /// **Suggestion**: If I missed a common asset type that should be supported out-of-the-box, please open an issue or PR to add it!
    fn register_dlc_type<T: Asset>(&mut self) -> &mut Self;
}

impl AppExt for App {
    fn register_dlc_type<T: Asset>(&mut self) -> &mut Self {
        self.init_asset_loader::<DlcLoader<T>>();
        self
    }
}

/// Strongly-typed DLC identifier (string-backed).
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
#[serde(transparent)]
pub struct DlcId(pub String);

// convenience impls
impl From<&str> for DlcId {
    fn from(s: &str) -> Self {
        DlcId(s.to_owned())
    }
}

impl From<String> for DlcId {
    fn from(s: String) -> Self {
        DlcId(s)
    }
}

impl std::fmt::Display for DlcId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        self.0.fmt(f)
    }
}

/// Bevy plugin that enables DLC!
///
/// About `SignedLicense`:
/// - `SignedLicense` is a zeroized `String` containing a compact
///   offline-signed token (format: `payload_base64url.signature_base64url`).
/// - Tokens are produced by `DlcKey::create_signed_license` (private key)
///   or by platform tooling. When generated by a private `DlcKey` a token
///   may include an embedded `content_key` used to decrypt DLC assets at
///   runtime — that symmetric key is not exposed by `VerifiedLicense`.
/// - Treat `SignedLicense` as sensitive: provision it securely (platform,
///   secure backend, or out-of-band) and do not leak raw secrets in logs.
///
/// Usage: provide the game with the public `DlcKey` and hand the signed
/// license token (for example, from your platform or the CLI pack output)
/// to the plugin; the plugin will apply the token to `DlcManager` and
/// provision content keys as needed.
pub struct DlcPlugin {
    // keep the provided key (public or private) so `build` can insert it into
    // app resources; field is private to avoid exposing internals.
    dlc_key: DlcKey,
    // Signed license token provided at construction; applied to the plugin's
    // internal `DlcManager` during `build`.
    signed_license: SignedLicense,
    // The plugin owns a `DlcManager` instance which will be populated by
    // applying the signed license at build time and then inserted as a
    // resource for the app to use.
    dlc_manager: DlcManager,
}

impl DlcPlugin {
    /// Create the plugin from a `DlcKey` and a `SignedLicense`.
    ///
    /// The plugin will attempt to apply the signed token to an internal
    /// `DlcManager` during `build` and then insert that `DlcManager` as a
    /// resource so game systems do not need to call
    /// `DlcManager::apply_signed_key_token` in `startup` themselves.
    pub fn new(product: Product, dlc_key: DlcKey, signed_license: SignedLicense) -> Self {
        Self {
            dlc_key,
            signed_license,
            dlc_manager: DlcManager::new(product),
        }
    }
}

// secure-gate aliases for secrets used with `DlcKey`
fixed_alias!(pub PrivateKey, 32);

/// PublicKey wrapper (32 bytes)
#[derive(Clone, Copy, PartialEq, Eq)]
pub struct PublicKey([u8; 32]);

impl PublicKey {
    pub fn expose_secret(&self) -> &[u8; 32] {
        &self.0
    }
}

impl From<[u8; 32]> for PublicKey {
    fn from(v: [u8; 32]) -> Self {
        PublicKey(v)
    }
}

impl std::fmt::Debug for PublicKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PublicKey({} bytes)", 32)
    }
}

// `SignedLicense` — secure, heap-backed string wrapper (secure-gate)
dynamic_alias!(pub SignedLicense, String);

// `ExposeSecret` methods are provided by the alias; keeps the same public API surface.

/// Product: non-secret identifier wrapper (keeps same API surface)
#[derive(Clone, PartialEq, Eq, Debug)]
pub struct Product(String);

impl Product {
    pub fn get(&self) -> &String {
        &self.0
    }
}

impl From<String> for Product {
    fn from(s: String) -> Self {
        Product(s)
    }
}
impl From<&str> for Product {
    fn from(s: &str) -> Self {
        Product(s.to_owned())
    }
}

// `ContentKey`: secure heap-backed secret for symmetric keys
// use secure-gate's `Dynamic<Vec<u8>>` API (methods are provided by the alias)
dynamic_alias!(pub ContentKey, Vec<u8>, "A secure content key (symmetric key for encrypting DLC assets)");


/// Client-side wrapper for Ed25519 key operations: verify tokens and (when
/// private) create compact signed tokens.
#[derive(Resource)]
pub enum DlcKey {
    /// Private key (protected seed + public bytes + publickey tag)
    Private {
        /// Protected signing seed (secure wrapper)
        privkey: PrivateKey,
        /// Public key bytes (wrapped)
        pubkey: PublicKey,
    },

    /// Public-only key (public bytes)
    Public {
        /// Public key bytes (wrapped)
        pubkey: PublicKey,
    },
}

impl DlcKey {
    pub fn new(pubkey: &str, privkey: &str) -> Result<Self, DlcError> {
        let decoded_pub = URL_SAFE_NO_PAD
            .decode(pubkey.as_bytes())
            .map_err(|e| DlcError::CryptoError(format!("invalid pubkey base64: {}", e)))?;
        if decoded_pub.len() != 32 {
            return Err(DlcError::CryptoError("public key must be 32 bytes".into()));
        }
        let mut pub_bytes = [0u8; 32];
        pub_bytes.copy_from_slice(&decoded_pub);

        let decoded_priv = URL_SAFE_NO_PAD
            .decode(privkey.as_bytes())
            .map_err(|e| DlcError::CryptoError(format!("invalid privkey base64: {}", e)))?;
        if decoded_priv.len() != 32 {
            return Err(DlcError::CryptoError("private key must be 32 bytes".into()));
        }
        let mut priv_bytes = [0u8; 32];
        priv_bytes.copy_from_slice(&decoded_priv);

        Self::from_priv_and_pub(PrivateKey::from(priv_bytes), PublicKey::from(pub_bytes))
    }

    /// Construct a `DlcKey::Public` from a base64url-encoded public key string.
    pub fn public(pubkey: &str) -> Result<Self, DlcError> {
        let decoded_pub = URL_SAFE_NO_PAD
            .decode(pubkey.as_bytes())
            .map_err(|e| DlcError::CryptoError(format!("invalid pubkey base64: {}", e)))?;
        if decoded_pub.len() != 32 {
            return Err(DlcError::CryptoError("public key must be 32 bytes".into()));
        }
        let mut pub_bytes = [0u8; 32];
        pub_bytes.copy_from_slice(&decoded_pub);

        Ok(DlcKey::Public {
            pubkey: PublicKey::from(pub_bytes),
        })
    }

    /// Construct a `DlcKey::Private` from a private key and public key.
    pub(crate) fn from_priv_and_pub(
        privkey: PrivateKey,
        publickey: PublicKey,
    ) -> Result<Self, DlcError> {
        // derive public bytes from the protected seed and validate via
        // `from_seed_and_public_key` so we never sign using only the seed
        let kp = privkey.with_secret(|priv_bytes| {
            Ed25519KeyPair::from_seed_and_public_key(priv_bytes, publickey.expose_secret())
        })
        .map_err(|e| DlcError::CryptoError(format!("invalid seed: {:?}", e)))?;
        let mut pub_bytes = [0u8; 32];
        pub_bytes.copy_from_slice(kp.public_key().as_ref());

        // validate construction using both seed + public (preferred API)
        privkey.with_secret(|priv_bytes| {
            Ed25519KeyPair::from_seed_and_public_key(priv_bytes, &pub_bytes)
        })
        .map_err(|e| DlcError::CryptoError(format!("keypair validation failed: {:?}", e)))?;

        Ok(DlcKey::Private {
            privkey,
            pubkey: PublicKey::from(pub_bytes),
        })
    }


    /// Generate a new `DlcKey::Private` with a random seed and derived public key.
    ///
    /// The public key is derived from the generated seed so the keypair is valid.
    pub fn generate_random() -> Self {
        // generate a random seed and derive the matching public key from it
        let privkey: PrivateKey = PrivateKey::from_random();
        // derive public bytes from the seed using ring
        let pair = privkey
            .with_secret(|priv_bytes| Ed25519KeyPair::from_seed_unchecked(priv_bytes))
            .expect("derive public key from seed");
        let mut pub_bytes = [0u8; 32];
        pub_bytes.copy_from_slice(pair.public_key().as_ref());

        Self::from_priv_and_pub(privkey, PublicKey::from(pub_bytes))
            .unwrap_or_else(|e| panic!("generate_complete failed: {:?}", e))
    }

    /// Return the raw public key bytes (32 bytes) for either variant.
    pub fn public_key_bytes(&self) -> &[u8; 32] {
        match self {
            DlcKey::Private { pubkey: public, .. } => public.expose_secret(),
            DlcKey::Public { pubkey: public } => public.expose_secret(),
        }
    }

    #[cfg(test)]
    pub(crate) fn get_public_key(&self) -> &PublicKey {
        match self {
            DlcKey::Private { pubkey, .. } => pubkey,
            DlcKey::Public { pubkey: public } => public,
        }
    }

    /// Create a compact offline-signed token that can be verified by this key's public key.
    ///
    /// Returns a `SignedLicense` (zeroized on drop). The license payload includes
    /// the provided DLC ids and product binding.
    /// Create a compact offline-signed token (SignedLicense).
    pub fn create_signed_license<D>(
        &self,
        dlcs: impl IntoIterator<Item = D>,
        product: Product,
    ) -> Result<SignedLicense, DlcError>
    where
        D: std::fmt::Display,
    {
        let mut payload = serde_json::Map::new();
        payload.insert(
            "dlcs".to_string(),
            serde_json::Value::Array(
                dlcs.into_iter()
                    .map(|s| serde_json::Value::String(s.to_string()))
                    .collect(),
            ),
        );

        // product is required and always embedded
        payload.insert(
            "product".to_string(),
            serde_json::Value::String(product.get().to_string()),
        );

        match self {
            DlcKey::Private { privkey, pubkey } => {
                privkey.with_secret(|content_key_bytes| {
                    // use the private seed itself as the symmetric content key
                    payload.insert(
                        "content_key".to_string(),
                        serde_json::Value::String(URL_SAFE_NO_PAD.encode(content_key_bytes)),
                    );

                    let payload_value = serde_json::Value::Object(payload);
                    let payload_bytes = serde_json::to_vec(&payload_value)
                        .map_err(|e| DlcError::TokenCreationFailed(e.to_string()))?;

                    let pair = Ed25519KeyPair::from_seed_and_public_key(
                        content_key_bytes,
                        pubkey.expose_secret(),
                    )
                    .map_err(|e| DlcError::CryptoError(format!("keypair: {:?}", e)))?;
                    let sig = pair.sign(&payload_bytes);
                    Ok(SignedLicense::from(format!(
                        "{}.{}",
                        URL_SAFE_NO_PAD.encode(&payload_bytes),
                        URL_SAFE_NO_PAD.encode(sig.as_ref())
                    )))
                })
            }
            DlcKey::Public { .. } => Err(DlcError::PrivateKeyRequired),
        }
    }

    /// Create a signed key-token that carries a symmetric `content_key` (base64url).
    ///
    /// This is used for out-of-band provisioning of AES-256 content keys; the
    /// token is verified by `DlcKey::verify_signed_key_token` and applied with
    /// `DlcManager::apply_signed_key_token`.
    // Crate-internal helper to produce a signed *key-token* that carries a
    // symmetric content key. This is intentionally NOT public — platform
    // tooling (or examples/tests inside the crate) may use this, but end-users
    // should not handle content keys directly.

    /// Verify a compact signed-license (signature + payload) using this key's public key
    /// and return a typed `VerifiedLicense`. This only checks signature + parsing;
    /// product checks are performed by `DlcManager::unlock_verified_license`.
    pub fn verify_signed_license(
        &self,
        license: &SignedLicense,
    ) -> Result<VerifiedLicense, DlcError> {
        license.with_secret(|full_token| {
            let parts: Vec<&str> = full_token.split('.').collect();
            if parts.len() != 2 {
                return Err(DlcError::MalformedLicense(
                    "expected signed-license with two dot-separated parts".into(),
                ));
            }

            let payload = URL_SAFE_NO_PAD
                .decode(parts[0])
                .map_err(|e| DlcError::MalformedLicense(format!("payload base64: {}", e)))?;
            let sig_bytes = URL_SAFE_NO_PAD
                .decode(parts[1])
                .map_err(|e| DlcError::MalformedLicense(format!("signature base64: {}", e)))?;

            if sig_bytes.len() != 64 {
                return Err(DlcError::MalformedLicense(
                    "signature bytes length must be 64".into(),
                ));
            }

            let public = self.public_key_bytes();
            let public_key = UnparsedPublicKey::new(&ED25519, public);
            public_key
                .verify(&payload, &sig_bytes)
                .map_err(|_| DlcError::SignatureInvalid)?;

            let lic: LicensePayload = serde_json::from_slice(&payload)
                .map_err(|e| DlcError::PayloadInvalid(e.to_string()))?;

            // Ignore any embedded `content_key` in the token here — `verify_signed_license`
            // only validates signature and returns the logical license fields.
            Ok(VerifiedLicense {
                dlcs: lic.dlcs,
                iat: lic.iat,
                nonce: lic.nonce,
                product: lic.product,
            })
        })
    }

    /// Verify a signed key-token (signature + payload) using this key's public key and return a typed `VerifiedKeyToken` with the embedded symmetric content key.
    pub(crate) fn verify_signed_key_token(
        &self,
        token: &SignedLicense,
    ) -> Result<VerifiedKeyToken, DlcError> {
        token.with_secret(|full_token| {
            let parts: Vec<&str> = full_token.split('.').collect();
            if parts.len() != 2 {
                return Err(DlcError::MalformedLicense(
                    "expected signed-license with two dot-separated parts".into(),
                ));
            }

            let payload = URL_SAFE_NO_PAD
                .decode(parts[0])
                .map_err(|e| DlcError::MalformedLicense(format!("payload base64: {}", e)))?;
            let sig_bytes = URL_SAFE_NO_PAD
                .decode(parts[1])
                .map_err(|e| DlcError::MalformedLicense(format!("signature base64: {}", e)))?;

            if sig_bytes.len() != 64 {
                return Err(DlcError::MalformedLicense(
                    "signature bytes length must be 64".into(),
                ));
            }

            let public = self.public_key_bytes();
            let public_key = UnparsedPublicKey::new(&ED25519, public);
            public_key
                .verify(&payload, &sig_bytes)
                .map_err(|_| DlcError::SignatureInvalid)?;

            let lic: KeyPayload = serde_json::from_slice(&payload)
                .map_err(|e| DlcError::PayloadInvalid(e.to_string()))?;

            let key_bytes = URL_SAFE_NO_PAD
                .decode(lic.content_key.as_bytes())
                .map_err(|e| DlcError::MalformedLicense(format!("content_key base64: {}", e)))?;
            if key_bytes.len() != 32 {
                return Err(DlcError::InvalidContentKey(
                    "content_key must be 32 bytes".into(),
                ));
            }

            Ok(VerifiedKeyToken {
                dlcs: lic.dlcs,
                product: lic.product,
                content_key: ContentKey::from(key_bytes),
            })
        })
    }
}

// Manual Clone impl to allow `DlcKey` to be duplicated while keeping the
// secret data zeroized in the new copy (we cannot rely on secure-gate's
// `Clone` impl for aliases because inner types are not `CloneableSecret`).
impl Clone for DlcKey {
    fn clone(&self) -> Self {
        match self {
            DlcKey::Private { privkey, pubkey } => {
                // copy the seed bytes into a new `PrivateKey`
                let seed = privkey.with_secret(|s| *s);
                DlcKey::Private {
                    privkey: PrivateKey::new(seed),
                    pubkey: *pubkey,
                }
            }
            DlcKey::Public { pubkey } => DlcKey::Public { pubkey: *pubkey },
        }
    }
}

impl std::fmt::Display for DlcKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", URL_SAFE_NO_PAD.encode(self.public_key_bytes()))
    }
}

impl From<&DlcKey> for String {
    fn from(k: &DlcKey) -> Self {
        k.to_string()
    }
}

impl Plugin for DlcPlugin {
    fn build(&self, app: &mut App) {
        // prepare a DlcManager and try to both provision content keys (if
        // the token carries a content_key) and mark DLC ids as unlocked.
        let mut manager = self.dlc_manager.clone();

        // First try to treat the supplied token as a *key-token* (contains
        // an embedded `content_key`). If that succeeds, apply the symmetric
        // key(s) to the registry and also mark the DLC ids as unlocked.
        match self.dlc_key.verify_signed_key_token(&self.signed_license) {
            Ok(vkt) => {
                // build the non-secret VerifiedLicense first (clone non-secret fields),
                // then move the owned `vkt` into `apply_verified_key_token` so we avoid
                // cloning the embedded `content_key`.
                let vl = VerifiedLicense {
                    dlcs: vkt.dlcs.clone(),
                    iat: None,
                    nonce: None,
                    product: vkt.product.clone(),
                };

                if let Err(e) = manager.apply_verified_key_token(vkt) {
                    warn!("DlcPlugin: failed to apply verified key token: {:?}", e);
                }

                if let Err(e) = manager.unlock_verified_license(vl) {
                    warn!(
                        "DlcPlugin: failed to unlock DLC ids from key token: {:?}",
                        e
                    );
                }
            }
            Err(_) => {
                // Not a key-token — try to verify as a regular SignedLicense
                // and unlock the DLC ids. Failure is non-fatal (plugin will
                // still insert a usable DlcManager resource).
                match self.dlc_key.verify_signed_license(&self.signed_license) {
                    Ok(vl) => {
                        if let Err(e) = manager.unlock_verified_license(vl) {
                            warn!("DlcPlugin: failed to unlock DLC ids from license: {:?}", e);
                        }
                    }
                    Err(e) => warn!("DlcPlugin: signed license verification failed: {:?}", e),
                }
            }
        }

        // insert provided key + populated manager so other systems/resources can access them
        app.insert_resource(self.dlc_key.clone())
            .insert_resource(manager)
            .init_asset_loader::<asset_loader::DlcLoader<Image>>()
            .init_asset_loader::<asset_loader::DlcLoader<Scene>>()
            .init_asset_loader::<asset_loader::DlcLoader<bevy::mesh::Mesh>>()
            .init_asset_loader::<asset_loader::DlcLoader<Font>>()
            .init_asset_loader::<asset_loader::DlcLoader<AudioSource>>()
            //.init_resource::<Assets<asset_loader::DlcPack>>()
            .init_asset_loader::<asset_loader::DlcPackLoader>()
            .init_asset::<asset_loader::DlcPack>()
            .add_systems(Update, reload_assets_on_unlock_system);
    }
}

/// Resource that holds unlocked DLC IDs and verifies signed license tokens.
///
/// Security improvements:
/// - DLC ids are `DlcId<K>` (typed identifier) rather than raw strings.
/// - optional `product` binding can be set on the manager; if provided the
///   privatekey must include a matching `product` field. This helps prevent
///   cross-product reuse of tokens.
#[derive(Resource, Debug, Clone)]
pub struct DlcManager {
    unlocked: HashSet<DlcId>,
    product: Product,
}

impl DlcManager {
    /// Create a new, empty manager.
    pub fn new(product: Product) -> Self {
        Self {
            unlocked: HashSet::new(),
            product,
        }
    }

    /// Check whether a DLC is unlocked by `DlcId`.
    pub fn is_unlocked_id<'a>(&self, dlc_id: impl Into<&'a DlcId>) -> bool {
        self.unlocked.contains(dlc_id.into())
    }

    /// Return a list of currently unlocked DLC ids.
    pub fn unlocked_list(&self) -> Vec<DlcId> {
        self.unlocked.iter().cloned().collect()
    }

    /// Apply a previously-verified key token by inserting its symmetric key
    /// into the runtime registry for each DLC in the token.

    pub(crate) fn apply_verified_key_token(
        &mut self,
        vkt: VerifiedKeyToken,
    ) -> Result<(), DlcError> {
        // product binding
        if vkt.product != *self.product.get() {
            return Err(DlcError::TokenProductMismatch);
        }

        if vkt.dlcs.len() == 1 {
            // move the owned content_key when there's a single DLC id to avoid cloning
            crate::content_key_registry::insert(&vkt.dlcs[0], vkt.content_key);
        } else {
            // borrow secret and clone bytes for each DLC id
            vkt.content_key.with_secret(|b| {
                for id in &vkt.dlcs {
                    crate::content_key_registry::insert(id, ContentKey::from(b.to_vec()));
                }
            });
        }

        Ok(())
    }

    /// Convenience: verify a signed key-token with `verifier` and apply it.
    pub fn apply_signed_key_token(
        &mut self,
        verifier: &DlcKey,
        token: &SignedLicense,
    ) -> Result<(), DlcError> {
        let vkt = verifier.verify_signed_key_token(token)?;
        self.apply_verified_key_token(vkt)
    }
}

impl Default for DlcManager {
    fn default() -> Self {
        Self {
            unlocked: HashSet::new(),
            product: Product::from("default"),
        }
    }
}

impl DlcManager {
    /// Unlock DLC IDs from a previously-verified `VerifiedLicense`.
    ///
    /// Performs product checks and unlocks DLC IDs.
    pub fn unlock_verified_license(&mut self, vt: VerifiedLicense) -> Result<Vec<DlcId>, DlcError> {
        // product binding (if manager requires a product)
        if vt.product != *self.product.get() {
            return Err(DlcError::TokenProductMismatch);
        }

        let mut unlocked_ids = Vec::new();
        for id in &vt.dlcs {
            let did = DlcId::from(id.clone());
            self.unlocked.insert(did.clone());

            unlocked_ids.push(did);
        }

        Ok(unlocked_ids)
    }
}

/// A small wrapper that associates an asset Handle with a DLC id.
/// Use `is_unlocked` to check whether the DLC is available; callers can
/// then clone the `handle` when they need it.
#[derive(Clone, Debug)]
pub struct DlcHandle<T: Asset> {
    pub handle: Handle<T>,
    pub dlc_id: DlcId,
}

impl<T: Asset> DlcHandle<T> {
    pub fn new(handle: Handle<T>, dlc_id: impl Into<DlcId>) -> Self {
        Self {
            handle,
            dlc_id: dlc_id.into(),
        }
    }

    /// Convenience check.
    pub fn is_unlocked(&self, dlc: &DlcManager) -> bool {
        dlc.is_unlocked_id(&self.dlc_id)
    }
}

/// Bevy `run_if` condition generator — use this to make a system run only
/// when a particular DLC is unlocked. Example:
///
/// `add_systems(Update, my_system.run_if(dlc_unlocked("expansion_1")))`
pub fn dlc_unlocked(dlc_id: impl Into<DlcId>) -> impl Fn(Res<DlcManager>) -> bool {
    let id = dlc_id.into();
    move |dlc: Res<DlcManager>| dlc.is_unlocked_id(&id)
}

/// System that reloads any asset paths registered for DLC ids that have just
/// become unlocked. This allows `AssetLoader`s to register paths they are
/// responsible for and have those assets retried automatically after the
/// relevant content key arrives.
fn reload_assets_on_unlock_system(
    dlc: Res<DlcManager>,
    asset_server: Res<AssetServer>,
    mut seen: Local<std::collections::HashSet<String>>,
) {
    for did in dlc.unlocked_list() {
        let id_str = did.to_string();
        if seen.contains(&id_str) {
            continue;
        }
        for path in crate::content_key_registry::asset_paths_for(&id_str) {
            asset_server.reload(path);
        }
        seen.insert(id_str);
    }
}

#[derive(Serialize, Deserialize, Debug)]
struct LicensePayload {
    pub dlcs: Vec<String>,
    pub iat: Option<u64>,
    pub nonce: Option<String>,
    pub product: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub content_key: Option<String>,
}

/// Typed, verified privatekey returned by `DlcKey::verify_signed_license`.
#[derive(Debug, Clone)]
pub struct VerifiedLicense {
    /// List of DLC ids included in the token (as strings; these are converted to `DlcId` when applied/unlocked).
    pub dlcs: Vec<String>,
    /// Issued-at timestamp (optional) — not validated by the crate but can be used
    pub iat: Option<u64>,
    /// Optional nonce (e.g. for replay protection) — not validated by the crate but can be used by platforms that require it.
    pub nonce: Option<String>,
    /// Product binding (string) — this is checked against the manager's product when unlocking, but the crate does not enforce any particular format for this field.
    pub product: String,
}

/// Payload for a signed *key-token* (a `SignedLicense` whose payload carries a base64url `content_key`).
#[derive(Serialize, Deserialize, Debug)]
struct KeyPayload {
    pub dlcs: Vec<String>,
    pub product: String,
    pub content_key: String, // base64url
}

#[derive(Debug)]
pub(crate) struct VerifiedKeyToken {
    pub dlcs: Vec<String>,
    pub product: String,
    content_key: ContentKey,
}

// AES-GCM helper used to decrypt shipped assets once the DLC is unlocked.
fn decrypt_with_key(
    key: &ContentKey,
    ciphertext: &[u8],
    nonce: &[u8],
) -> Result<Vec<u8>, DlcError> {
    key.with_secret(|key_bytes| {
        if key_bytes.len() != 32 {
            return Err(DlcError::InvalidContentKey(
                "content key must be 32 bytes (AES-256)".into(),
            ));
        }
        if nonce.len() != 12 {
            return Err(DlcError::InvalidNonce(
                "nonce must be 12 bytes (AES-GCM)".into(),
            ));
        }
        let cipher =
            Aes256Gcm::new_from_slice(key_bytes).map_err(|e| DlcError::CryptoError(e.to_string()))?;
        let nonce = Nonce::from_slice(nonce);
        cipher
            .decrypt(nonce, ciphertext)
            .map_err(|_| DlcError::DecryptionFailed)
    })
}

// Encoded format (base64url): salt(16) || nonce(12) || ciphertext

/// Pack plaintext bytes into the crate's encrypted container format and
/// return the serialized container bytes plus the random nonce used for AES-GCM.
///
/// - `original_extension` is the original file extension (e.g. "png" or
///   "json") and is stored in the container so loaders can prefer the
///   appropriate nested loader.
pub fn pack_encrypted_asset(
    plaintext: &[u8],
    dlc_id: &DlcId,
    original_extension: Option<&str>,
    original_type: Option<&str>,
    key: &ContentKey,
) -> Result<(Vec<u8>, [u8; 12]), DlcError> {
    if key.len() != 32 {
        return Err(DlcError::InvalidContentKey(
            "content key must be 32 bytes (AES-256)".into(),
        ));
    }

    let cipher = key.with_secret(|kb| Aes256Gcm::new_from_slice(kb.as_slice())
        .map_err(|e| DlcError::CryptoError(e.to_string())))?;
    let nonce_bytes: [u8; 12] = rand::random();
    let nonce = Nonce::from_slice(&nonce_bytes);
    let ciphertext = cipher
        .encrypt(nonce, plaintext)
        .map_err(|_| DlcError::EncryptionFailed("encryption failed".into()))?;

    // version 1
    let version = 1u8;

    let mut out = Vec::new();
    out.extend_from_slice(DLC_ASSET_MAGIC);
    out.push(version);

    let id = dlc_id.to_string();
    let dlc_bytes = id.as_bytes();
    out.extend_from_slice(&(dlc_bytes.len() as u16).to_be_bytes());
    out.extend_from_slice(dlc_bytes);

    let ext = original_extension.unwrap_or("");
    out.push(ext.len() as u8);
    out.extend_from_slice(ext.as_bytes());

    // version 1 includes the type field (u16 length + utf8 bytes)
    let t = original_type.unwrap_or("");
    out.extend_from_slice(&(t.len() as u16).to_be_bytes());
    out.extend_from_slice(t.as_bytes());

    out.extend_from_slice(&nonce_bytes);
    out.extend_from_slice(&ciphertext);

    Ok((out, nonce_bytes))
}

/// Low-level helper that constructs the container bytes from already-encrypted
/// ciphertext (keeps packing logic in one place). Useful when encryption is
/// performed externally.
pub fn build_encrypted_container_bytes(
    dlc_id: &str,
    original_extension: Option<&str>,
    original_type: Option<&str>,
    nonce: [u8; 12],
    ciphertext: &[u8],
) -> Vec<u8> {
    let mut out = Vec::new();
    out.extend_from_slice(DLC_ASSET_MAGIC);
    out.push(1u8); // version 1
    let dlc_bytes = dlc_id.as_bytes();
    out.extend_from_slice(&(dlc_bytes.len() as u16).to_be_bytes());
    out.extend_from_slice(dlc_bytes);

    let ext = original_extension.unwrap_or("");
    out.push(ext.len() as u8);
    out.extend_from_slice(ext.as_bytes());

    // version 1 includes the type field (u16 length + utf8 bytes)
    let t = original_type.unwrap_or("");
    out.extend_from_slice(&(t.len() as u16).to_be_bytes());
    out.extend_from_slice(t.as_bytes());

    out.extend_from_slice(&nonce);
    out.extend_from_slice(ciphertext);
    out
}

/// Pack multiple entries into a single `.dlcpack` container.
/// New format (version 2):
/// `magic(4)='BDLP' | version(1) | dlc_len(u16) | dlc_id |
///    manifest_len(u32) | manifest(json) | nonce(12) | ciphertext_len(u32) | ciphertext`
///
/// - The manifest is a JSON array of objects: { path, original_extension?, type_path? } and is stored in the pack header (plaintext) so the CLI / tools can list entries without decrypting.
/// - The archive is a gzip-compressed tar (`.tar.gz`) of the raw plaintext files (paths preserved) and the entire compressed archive is encrypted as a single AES-GCM ciphertext using `key`.
///
/// Legacy behavior (per-entry encrypted items) is still supported by `parse_encrypted_pack`.
pub fn pack_encrypted_pack(
    dlc_id: &DlcId,
    items: &[(String, Option<String>, Option<String>, Vec<u8>)],
    key: &ContentKey,
) -> Result<Vec<u8>, DlcError> {
    if key.len() != 32 {
        return Err(DlcError::InvalidContentKey(
            "content key must be 32 bytes (AES-256)".into(),
        ));
    }

    // refuse inputs that already look like BDLC / BDLP containers
    for (path, _ext_opt, _type_opt, plaintext) in items {
        if plaintext.len() >= 4
            && (plaintext.starts_with(DLC_ASSET_MAGIC) || plaintext.starts_with(DLC_PACK_MAGIC))
        {
            return Err(DlcError::Other(format!(
                "cannot pack existing dlc or dlcpack container as an item: {}",
                path
            )));
        }
    }

    // Build a tar.gz archive (in-memory) containing the plaintext files at
    // their requested relative paths.
    use flate2::{Compression, write::GzEncoder};
    use tar::Builder;

    let mut tar_gz: Vec<u8> = Vec::new();
    {
        let enc = GzEncoder::new(&mut tar_gz, Compression::default());
        let mut tar = Builder::new(enc);
        for (path, _ext_opt, _type_opt, plaintext) in items {
            let mut header = tar::Header::new_gnu();
            header.set_size(plaintext.len() as u64);
            header.set_mode(0o644);
            header.set_cksum();
            // append_data takes a reader; Cursor over the slice is convenient
            tar.append_data(&mut header, path, &mut std::io::Cursor::new(plaintext))
                .map_err(|e| DlcError::Other(e.to_string()))?;
        }
        // finish the tar builder to flush into the gzip encoder
        let enc = tar
            .into_inner()
            .map_err(|e| DlcError::Other(e.to_string()))?;
        // finish the gzip encoder explicitly to ensure all data is written
        let _ = enc.finish().map_err(|e| DlcError::Other(e.to_string()))?;
    }

    // produce AES-GCM ciphertext for the whole compressed archive
    let cipher = key.with_secret(|kb| Aes256Gcm::new_from_slice(kb.as_slice())
        .map_err(|e| DlcError::CryptoError(e.to_string())))?;
    // generate a random nonce for this encryption (12 bytes for AES-GCM); this is stored in the container header so the caller can provide it for decryption later
    let nonce_bytes: [u8; 12] = rand::random();
    let nonce = Nonce::from_slice(&nonce_bytes);
    let ciphertext = cipher
        .encrypt(nonce, tar_gz.as_slice())
        .map_err(|_| DlcError::EncryptionFailed("encryption failed".into()))?;

    // prepare manifest (JSON) with per-entry metadata so tools can inspect packs
    #[derive(serde::Serialize)]
    struct ManifestEntry<'a> {
        path: &'a str,
        #[serde(skip_serializing_if = "Option::is_none")]
        original_extension: Option<&'a str>,
        #[serde(skip_serializing_if = "Option::is_none")]
        type_path: Option<&'a str>,
    }

    let mut manifest: Vec<ManifestEntry<'_>> = Vec::with_capacity(items.len());
    for (path, ext_opt, type_opt, _plaintext) in items {
        manifest.push(ManifestEntry {
            path: path.as_str(),
            original_extension: ext_opt.as_deref(),
            type_path: type_opt.as_deref(),
        });
    }
    let manifest_bytes =
        serde_json::to_vec(&manifest).map_err(|e| DlcError::Other(e.to_string()))?;

    // serialize BDLP: magic | version(2) | dlc_len(u16) | dlc_id | manifest_len(u32) | manifest | nonce | ciphertext_len(u32) | ciphertext
    let mut out = Vec::new();
    out.extend_from_slice(DLC_PACK_MAGIC);
    out.push(2u8); // version 2 (archive-encrypted)

    let id = dlc_id.to_string();
    let dlc_bytes = id.as_bytes();
    out.extend_from_slice(&(dlc_bytes.len() as u16).to_be_bytes());
    out.extend_from_slice(dlc_bytes);

    out.extend_from_slice(&(manifest_bytes.len() as u32).to_be_bytes());
    out.extend_from_slice(&manifest_bytes);

    out.extend_from_slice(&nonce_bytes);
    out.extend_from_slice(&(ciphertext.len() as u32).to_be_bytes());
    out.extend_from_slice(&ciphertext);

    Ok(out)
}

/// .dlc container magic header (4 bytes) used to identify encrypted asset containers.
pub const DLC_ASSET_MAGIC: &[u8; 4] = b"BDLC";
/// .dlcpack container magic header (4 bytes) used to identify encrypted pack containers.
pub const DLC_PACK_MAGIC: &[u8; 4] = b"BDLP";

/// Parse a `.dlcpack` container and return the embedded `dlc_id` and a list
/// of `(path, EncryptedAsset)` pairs. The returned `EncryptedAsset` values
/// will contain the same `dlc_id` for every entry.
pub fn parse_encrypted_pack(
    bytes: &[u8],
) -> Result<
    (
        String,
        usize,
        Vec<(String, crate::asset_loader::EncryptedAsset)>,
    ),
    std::io::Error,
> {
    use std::io::ErrorKind;

    // basic validation and header parsing
    if bytes.len() < 4 + 1 {
        return Err(std::io::Error::new(
            ErrorKind::InvalidData,
            "dlcpack too small",
        ));
    }
    if &bytes[0..4] != DLC_PACK_MAGIC {
        return Err(std::io::Error::new(
            ErrorKind::InvalidData,
            "invalid dlcpack magic",
        ));
    }
    let version = bytes[4];
    let mut offset = 5usize;

    let dlc_len = u16::from_be_bytes([bytes[offset], bytes[offset + 1]]) as usize;
    offset += 2;
    if offset + dlc_len > bytes.len() {
        return Err(std::io::Error::new(
            ErrorKind::InvalidData,
            "invalid dlc id length",
        ));
    }
    let dlc_id = String::from_utf8(bytes[offset..offset + dlc_len].to_vec())
        .map_err(|e| std::io::Error::new(ErrorKind::InvalidData, e))?;
    offset += dlc_len;

    // Versioned parsing: v1 = per-entry encrypted items, v2 = single encrypted gzip archive + plaintext manifest
    if version == 1 {
        // legacy format
        let entry_count = u16::from_be_bytes([bytes[offset], bytes[offset + 1]]) as usize;
        offset += 2;

        let mut entries = Vec::with_capacity(entry_count);
        for _ in 0..entry_count {
            if offset + 2 > bytes.len() {
                return Err(std::io::Error::new(
                    ErrorKind::InvalidData,
                    "missing path_len",
                ));
            }
            let path_len = u16::from_be_bytes([bytes[offset], bytes[offset + 1]]) as usize;
            offset += 2;
            if offset + path_len > bytes.len() {
                return Err(std::io::Error::new(
                    ErrorKind::InvalidData,
                    "invalid path length",
                ));
            }
            let path = String::from_utf8(bytes[offset..offset + path_len].to_vec())
                .map_err(|e| std::io::Error::new(ErrorKind::InvalidData, e))?;
            offset += path_len;

            if offset + 1 > bytes.len() {
                return Err(std::io::Error::new(
                    ErrorKind::InvalidData,
                    "missing ext_len",
                ));
            }
            let ext_len = bytes[offset] as usize;
            offset += 1;
            let original_extension = if ext_len == 0 {
                return Err(std::io::Error::new(
                    ErrorKind::InvalidData,
                    "missing original extension",
                ));
            } else {
                if offset + ext_len > bytes.len() {
                    return Err(std::io::Error::new(
                        ErrorKind::InvalidData,
                        "invalid ext length",
                    ));
                }
                let s = String::from_utf8(bytes[offset..offset + ext_len].to_vec())
                    .map_err(|e| std::io::Error::new(ErrorKind::InvalidData, e))?;
                offset += ext_len;
                s
            };

            // version 1+ stores an optional serialized type identifier per entry
            let original_type = if version >= 1 {
                if offset + 2 > bytes.len() {
                    return Err(std::io::Error::new(
                        ErrorKind::InvalidData,
                        "missing type_path len",
                    ));
                }
                let tlen = u16::from_be_bytes([bytes[offset], bytes[offset + 1]]) as usize;
                offset += 2;
                if tlen == 0 {
                    None
                } else {
                    if offset + tlen > bytes.len() {
                        return Err(std::io::Error::new(
                            ErrorKind::InvalidData,
                            "invalid type_path length",
                        ));
                    }
                    let s = String::from_utf8(bytes[offset..offset + tlen].to_vec())
                        .map_err(|e| std::io::Error::new(ErrorKind::InvalidData, e))?;
                    offset += tlen;
                    Some(s)
                }
            } else {
                None
            };

            if offset + 12 + 4 > bytes.len() {
                return Err(std::io::Error::new(
                    ErrorKind::InvalidData,
                    "truncated entry",
                ));
            }
            let mut nonce = [0u8; 12];
            nonce.copy_from_slice(&bytes[offset..offset + 12]);
            offset += 12;
            let ciphertext_len = u32::from_be_bytes([
                bytes[offset],
                bytes[offset + 1],
                bytes[offset + 2],
                bytes[offset + 3],
            ]) as usize;
            offset += 4;
            if offset + ciphertext_len > bytes.len() {
                return Err(std::io::Error::new(
                    ErrorKind::InvalidData,
                    "truncated ciphertext",
                ));
            }
            let ciphertext = bytes[offset..offset + ciphertext_len].to_vec();
            offset += ciphertext_len;

            let enc = crate::asset_loader::EncryptedAsset {
                dlc_id: dlc_id.clone(),
                original_extension,
                type_path: original_type,
                nonce,
                ciphertext,
            };
            entries.push((path, enc));
        }

        Ok((dlc_id, 1usize, entries))
    } else if version >= 2 {
        // new archive-encrypted format: read manifest (u32 len + JSON), then nonce + ciphertext
        if offset + 4 > bytes.len() {
            return Err(std::io::Error::new(
                ErrorKind::InvalidData,
                "missing manifest_len",
            ));
        }
        let manifest_len = u32::from_be_bytes([
            bytes[offset],
            bytes[offset + 1],
            bytes[offset + 2],
            bytes[offset + 3],
        ]) as usize;
        offset += 4;
        if offset + manifest_len > bytes.len() {
            return Err(std::io::Error::new(
                ErrorKind::InvalidData,
                "truncated manifest",
            ));
        }
        let manifest_bytes = &bytes[offset..offset + manifest_len];
        offset += manifest_len;
        let manifest: Vec<serde_json::Value> = serde_json::from_slice(manifest_bytes)
            .map_err(|e| std::io::Error::new(ErrorKind::InvalidData, e))?;

        if offset + 12 + 4 > bytes.len() {
            return Err(std::io::Error::new(
                ErrorKind::InvalidData,
                "truncated archive",
            ));
        }
        let mut nonce = [0u8; 12];
        nonce.copy_from_slice(&bytes[offset..offset + 12]);
        offset += 12;
        let ciphertext_len = u32::from_be_bytes([
            bytes[offset],
            bytes[offset + 1],
            bytes[offset + 2],
            bytes[offset + 3],
        ]) as usize;
        offset += 4;
        if offset + ciphertext_len > bytes.len() {
            return Err(std::io::Error::new(
                ErrorKind::InvalidData,
                "truncated ciphertext",
            ));
        }
        let ciphertext = bytes[offset..offset + ciphertext_len].to_vec();

        // Construct per-entry metadata entries that reference the shared ciphertext
        let mut entries = Vec::with_capacity(manifest.len());
        for v in manifest.into_iter() {
            let path = v
                .get("path")
                .and_then(|p| p.as_str())
                .ok_or_else(|| {
                    std::io::Error::new(ErrorKind::InvalidData, "manifest entry missing path")
                })?
                .to_string();
            let original_extension = v
                .get("original_extension")
                .and_then(|e| e.as_str())
                .unwrap_or("");
            let type_path = v
                .get("type_path")
                .and_then(|t| t.as_str())
                .map(|s| s.to_string());

            let enc = crate::asset_loader::EncryptedAsset {
                dlc_id: dlc_id.clone(),
                original_extension: original_extension.to_string(),
                type_path,
                nonce,
                ciphertext: ciphertext.clone(),
            };
            entries.push((path, enc));
        }

        Ok((dlc_id, version as usize, entries))
    } else {
        Err(std::io::Error::new(
            ErrorKind::InvalidData,
            "unsupported dlcpack version",
        ))
    }
}

#[derive(Error, Debug, Clone)]
pub enum DlcError {
    #[error("invalid public key: {0}")]
    InvalidPublicKey(String),
    #[error("malformed privatekey: {0}")]
    MalformedLicense(String),
    #[error("signature verification failed")]
    SignatureInvalid,
    #[error("payload parse failed: {0}")]
    PayloadInvalid(String),

    // privatekey / crypto specific
    #[error("privatekey creation failed: {0}")]
    TokenCreationFailed(String),
    #[error("private key required for this operation")]
    PrivateKeyRequired,
    #[error("invalid publickey")]
    InvalidPassphrase,
    #[error("crypto error: {0}")]
    CryptoError(String),

    // encryption / decryption
    #[error("encryption failed: {0}")]
    EncryptionFailed(String),
    #[error("")]
    DecryptionFailed,
    #[error("invalid content key: {0}")]
    InvalidContentKey(String),
    #[error("invalid nonce: {0}")]
    InvalidNonce(String),

    // DLC / content-key state
    #[error("dlc locked: {0}")]
    DlcLocked(String),
    #[error(
        "no content key for dlc: {0} (hint: provide a signed key token via DlcManager::apply_signed_key_token)"
    )]
    NoContentKey(String),

    // privatekey binding mismatches
    #[error("privatekey product does not match")]
    TokenProductMismatch,

    // fallback
    #[error("{0}")]
    Other(String),
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn verify_and_unlock_token_roundtrip() {
        // generate a matching keypair for the test
        let key = DlcKey::generate_random();

        let product = Product::from("test");
        let token = key
            .create_signed_license(&[String::from("expansion_1")], product.clone())
            .expect("create privatekey");

        let mut manager = DlcManager::new(product);
        let vt = key
            .verify_signed_license(&token)
            .expect("verify privatekey");
        let unlocked = manager.unlock_verified_license(vt).expect("should verify");
        assert_eq!(unlocked, vec![DlcId::from("expansion_1")]);
        assert!(manager.is_unlocked_id(&DlcId::from("expansion_1")));
    }

    #[test]
    fn create_and_verify_signed_key_token_roundtrip() {
        let key = DlcKey::generate_random();

        // create a signed license that embeds the private seed as the content_key
        let token = key
            .create_signed_license(&["expansion_1"], Product::from("test"))
            .expect("create license");

        let pubkey = key.get_public_key().clone();
        let verifier = DlcKey::Public { pubkey };
        let vkt = verifier
            .verify_signed_key_token(&token)
            .expect("verify key token");
        assert_eq!(vkt.dlcs, vec![String::from("expansion_1")]);

        match key {
            DlcKey::Private { ref privkey, .. } => {
                vkt.content_key.with_secret(|got| {
                    privkey.with_secret(|expected| {
                        assert_eq!(got.as_slice(), expected);
                    })
                });
            }
            _ => unreachable!(),
        }
    }

    #[test]
    fn manager_apply_signed_key_token_inserts_key() {
        let key = DlcKey::generate_random();

        let product = Product::from("test");
        let token = key
            .create_signed_license(&["expansion_abc"], product.clone())
            .expect("create license");

        let pubkey = key.get_public_key().clone();
        let verifier = DlcKey::Public { pubkey };
        let mut manager = DlcManager::new(product);
        manager
            .apply_signed_key_token(&verifier, &token)
            .expect("apply token");

        let got = crate::content_key_registry::get("expansion_abc").expect("content key present");
        match key {
            DlcKey::Private { ref privkey, .. } => {
                got.with_secret(|b| {
                    privkey.with_secret(|expected| {
                        assert_eq!(b.as_slice(), expected);
                    })
                });
            }
            _ => unreachable!(),
        }
    }

    #[test]
    fn dlc_key_from_protected_seed() {
        // create a matching protected seed + public key pair
        let orig_key = DlcKey::generate_random();
        let protected = match orig_key {
            DlcKey::Private { ref privkey, .. } => privkey.with_secret(|b| PrivateKey::new(*b)),
            _ => unreachable!(),
        };
        let key = DlcKey::from_priv_and_pub(protected, orig_key.get_public_key().clone())
            .expect("from_seed");

        let product = Product::from("test");
        let signedlicense = key
            .create_signed_license(&[String::from("expansion_1")], product.clone())
            .expect("create privatekey");

        let mut manager = DlcManager::new(product);
        let vt = key
            .verify_signed_license(&signedlicense)
            .expect("verify privatekey");
        let unlocked = manager.unlock_verified_license(vt).expect("verify");
        assert_eq!(unlocked, vec![DlcId::from("expansion_1")]);
    }

    #[test]
    fn dlc_key_generate_and_verify() {
        let key = DlcKey::generate_random();
        let product = Product::from("test");
        let signedlicense = key
            .create_signed_license(&[String::from("expansion_1")], product.clone())
            .expect("create privatekey");

        let mut manager = DlcManager::new(product);
        let vt = key
            .verify_signed_license(&signedlicense)
            .expect("verify privatekey");
        let unlocked = manager.unlock_verified_license(vt).expect("verify");
        assert_eq!(unlocked, vec![DlcId::from("expansion_1")]);
        assert!(manager.is_unlocked_id(&DlcId::from("expansion_1")));
    }

    #[test]
    fn pack_and_parse_roundtrip() {
        let content_key = ContentKey::from_random(32);
        let plaintext = b"hello dlc v2";
        let (container, _nonce) = pack_encrypted_asset(
            plaintext,
            &DlcId::from("my_dlc"),
            Some("json"),
            None,
            &content_key,
        )
        .expect("pack");

        let enc = parse_encrypted(&container).expect("parse");
        assert_eq!(enc.dlc_id, "my_dlc");
        assert_eq!(enc.original_extension, "json");
        // type_path is None because None was passed to pack_encrypted_asset
        assert!(enc.type_path.is_none());
        let decrypted =
            decrypt_with_key(&content_key, &enc.ciphertext, &enc.nonce).expect("decrypt");
        assert_eq!(decrypted, plaintext);
    }

    #[test]
    fn pack_encrypted_pack_rejects_nested_dlc() {
        let content_key = ContentKey::from_random(32);
        let dlc_id = DlcId::from("pack_test");
        let items = vec![("a.txt".to_string(), Some("txt".to_string()), None, {
            let mut v = Vec::new();
            v.extend_from_slice(b"BDLC");
            v.extend_from_slice(b"inner");
            v
        })];
        let res = pack_encrypted_pack(&dlc_id, &items, &content_key);
        assert!(matches!(res, Err(DlcError::Other(_))));
    }

    #[test]
    fn pack_encrypted_pack_rejects_nested_dlcpack() {
        let key = ContentKey::from_random(32);
        let dlc_id = DlcId::from("pack_test");
        let items = vec![("b.bin".to_string(), None, None, {
            let mut v = Vec::new();
            v.extend_from_slice(b"BDLP");
            v.extend_from_slice(b"innerpack");
            v
        })];
        let res = pack_encrypted_pack(&dlc_id, &items, &key);
        assert!(matches!(res, Err(DlcError::Other(_))));
    }

    #[test]
    fn dlc_id_serde_roundtrip() {
        let id = DlcId::from("expansion_serde");
        let s = serde_json::to_string(&id).expect("serialize dlc id");
        assert_eq!(s, "\"expansion_serde\"");
        let decoded: DlcId = serde_json::from_str(&s).expect("deserialize dlc id");
        assert_eq!(decoded.to_string(), "expansion_serde");
    }

    #[test]
    fn verify_and_unlock_token_with_dlc_key_param() {
        let key = DlcKey::generate_random();
        let product = Product::from("test");
        let token = key
            .create_signed_license(&[String::from("expansion_1")], product.clone())
            .expect("create privatekey");

        let vt = key
            .verify_signed_license(&token)
            .expect("verify privatekey");
        let mut manager = DlcManager::new(product);
        // unlock using the previously-verified privatekey
        let unlocked = manager
            .unlock_verified_license(vt)
            .expect("verify with dlckey");
        assert_eq!(unlocked, vec![DlcId::from("expansion_1")]);
    }
}
